 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/README.md b/README.md
index f263b9aa4e2ba0384f0587f0b1cf201b6037d123..8446fb58c6b80b660f34dc8b8e71dbbf99df848f 100644
--- a/README.md
+++ b/README.md
@@ -1 +1,40 @@
-# drum-hero
\ No newline at end of file
+# Drum Hero
+
+Mini jeu web inspir√© de Guitar Hero. Utilise un canvas pour afficher quatre pistes et des notes d√©filantes. Le code JavaScript g√®re la g√©n√©ration des notes, le timing, le scoring et les retours visuels.
+
+## D√©marrer
+
+1. Ouvre `index.html` dans un navigateur moderne (Chrome, Edge, Firefox).
+2. (Facultatif) Utilise le bouton **Charger un MP3** pour s√©lectionner un fichier audio local qui sera lu pendant la partie.
+3. Clique sur **D√©marrer** puis utilise les touches `D`, `F`, `J` et `K` pour frapper les notes au bon moment.
+
+## Mettre en ligne
+
+Le projet est enti√®rement statique (HTML/CSS/JS), tu peux donc le publier sur n'importe quel h√©bergeur de fichiers statiques :
+
+### GitHub Pages
+1. Cr√©e un d√©p√¥t GitHub et pousse les fichiers du dossier.
+2. Dans les param√®tres du d√©p√¥t, active **Pages** et choisis la branche (g√©n√©ralement `main`) et le dossier racine (`/`).
+3. Patiente quelques minutes : ton jeu sera disponible √† l'URL `https://<ton-compte>.github.io/<nom-du-depot>/`.
+
+### Netlify (drag & drop)
+1. Connecte-toi sur [https://app.netlify.com/drop](https://app.netlify.com/drop).
+2. Glisse le dossier `drum-hero` complet dans la zone pr√©vue.
+3. Netlify d√©ploie automatiquement ton site et te fournit une URL que tu peux partager.
+
+### Serveur statique maison
+1. Lance un petit serveur HTTP local, par exemple :
+   ```bash
+   npx serve .
+   ```
+2. Mets en ligne le contenu g√©n√©r√© (`index.html`, `styles.css`, `script.js`) sur ton h√©bergement.
+
+## Fonctionnalit√©s
+
+- **Loop d'animation** fluide (requestAnimationFrame) avec un syst√®me de fen√™tres de timing (Parfait, Super, Bien, Rat√©).
+- **Piste r√©active** : flash sur la zone d'impact, affichage du combo et de la pr√©cision en temps r√©el.
+- **Chart de d√©monstration** g√©n√©r√© proc√©duralement pour tester le jeu.
+- **Fen√™tre de r√©sultat** r√©capitulative (score, pr√©cision, meilleur combo).
+- **Lecture audio** : support du chargement de fichiers MP3 locaux via l'API Web Audio.
+
+Le code est pens√© pour √™tre facilement extensible : il suffit d'adapter `createDemoChart()` pour charger une partition depuis un fichier JSON ou un backend.
diff --git a/index.html b/index.html
new file mode 100644
index 0000000000000000000000000000000000000000..0b2bccb262183ec90ade9a2647012596bfe54be0
--- /dev/null
+++ b/index.html
@@ -0,0 +1,76 @@
+<!DOCTYPE html>
+<html lang="fr">
+  <head>
+    <meta charset="utf-8" />
+    <meta name="viewport" content="width=device-width, initial-scale=1" />
+    <title>Drum Hero</title>
+    <link rel="stylesheet" href="styles.css" />
+  </head>
+  <body>
+    <header class="hud">
+      <h1>Drum Hero</h1>
+      <section class="stats">
+        <p><strong>Score :</strong> <span id="score">0</span></p>
+        <p><strong>Combo :</strong> <span id="combo">0</span></p>
+        <p><strong>Pr√©cision :</strong> <span id="accuracy">100%</span></p>
+      </section>
+      <button id="start-button" type="button">‚ñ∂Ô∏è D√©marrer</button>
+      <div class="audio-picker">
+        <label for="audio-file">üéµ Charger un MP3 :</label>
+        <input
+          id="audio-file"
+          type="file"
+          accept="audio/mpeg,audio/mp3,audio/*"
+        />
+        <p id="audio-status">Aucun fichier charg√©</p>
+      </div>
+    </header>
+
+    <main class="stage">
+      <div class="lanes" role="presentation">
+        <canvas id="playfield" width="480" height="640" aria-label="Piste de jeu"></canvas>
+        <div class="hit-line" aria-hidden="true"></div>
+        <div class="lane-labels" aria-hidden="true">
+          <span>D</span>
+          <span>F</span>
+          <span>J</span>
+          <span>K</span>
+        </div>
+      </div>
+      <aside class="panels">
+        <section class="panel">
+          <h2>Contr√¥les</h2>
+          <ul>
+            <li>Touche <kbd>D</kbd></li>
+            <li>Touche <kbd>F</kbd></li>
+            <li>Touche <kbd>J</kbd></li>
+            <li>Touche <kbd>K</kbd></li>
+          </ul>
+        </section>
+        <section class="panel">
+          <h2>Astuce</h2>
+          <p>
+            Appuie sur la touche correspondant √† la colonne lorsque la note
+            arrive sur la ligne blanche. Le timing compte !
+          </p>
+        </section>
+      </aside>
+    </main>
+
+    <footer>
+      <p>Jeu inspir√© par Guitar Hero. Code modernis√© pour de meilleures performances.</p>
+    </footer>
+
+    <dialog id="result-dialog">
+      <article>
+        <h2>Fin de partie</h2>
+        <p id="result-score"></p>
+        <p id="result-accuracy"></p>
+        <p id="result-combo"></p>
+        <button id="restart-button" type="button">Rejouer</button>
+      </article>
+    </dialog>
+
+    <script src="script.js" type="module"></script>
+  </body>
+</html>
diff --git a/script.js b/script.js
new file mode 100644
index 0000000000000000000000000000000000000000..afbdb2b4a055ce72206a1f50e4dfe0217ffebcee
--- /dev/null
+++ b/script.js
@@ -0,0 +1,476 @@
+const canvas = document.getElementById("playfield");
+const ctx = canvas.getContext("2d");
+
+const scoreLabel = document.getElementById("score");
+const comboLabel = document.getElementById("combo");
+const accuracyLabel = document.getElementById("accuracy");
+const startButton = document.getElementById("start-button");
+const resultDialog = document.getElementById("result-dialog");
+const restartButton = document.getElementById("restart-button");
+const resultScore = document.getElementById("result-score");
+const resultAccuracy = document.getElementById("result-accuracy");
+const resultCombo = document.getElementById("result-combo");
+const audioInput = document.getElementById("audio-file");
+const audioStatus = document.getElementById("audio-status");
+
+const AudioContextClass = window.AudioContext || window.webkitAudioContext;
+
+const LANES = ["d", "f", "j", "k"];
+const LANE_WIDTH = 100;
+const LANE_GAP = 10;
+const NOTE_HEIGHT = 28;
+const HIT_LINE_Y = canvas.height - 100;
+const SCROLL_SPEED = 360; // pixels / seconde
+const LOOKAHEAD = 2.5; // secondes
+
+const TIMING_WINDOWS = {
+  perfect: 55,
+  great: 95,
+  good: 140,
+};
+const SCORE_VALUES = { perfect: 300, great: 150, good: 60 };
+
+const laneColors = getComputedStyle(document.documentElement)
+  .getPropertyValue("--lane-colors")
+  .split(",")
+  .map((color) => color.trim());
+
+const laneStates = new Map(LANES.map((key) => [key, { pressed: false, flashUntil: 0 }]));
+
+const state = {
+  startTime: 0,
+  activeNotes: [],
+  pendingNotes: [],
+  animationFrame: 0,
+  running: false,
+  score: 0,
+  combo: 0,
+  bestCombo: 0,
+  totalNotes: 0,
+  successfulHits: 0,
+  lastJudgement: null,
+  lastJudgementTime: 0,
+};
+
+const audioState = {
+  context: null,
+  buffer: null,
+  source: null,
+  startTime: 0,
+  name: "",
+};
+
+class Note {
+  constructor(lane, time) {
+    this.lane = lane;
+    this.time = time;
+    this.hit = false;
+    this.missed = false;
+  }
+
+  get x() {
+    const laneIndex = LANES.indexOf(this.lane);
+    const totalWidth = LANES.length * LANE_WIDTH + (LANES.length - 1) * LANE_GAP;
+    const startX = (canvas.width - totalWidth) / 2;
+    return startX + laneIndex * (LANE_WIDTH + LANE_GAP);
+  }
+
+  get y() {
+    const elapsed = getElapsed();
+    const timeUntilHit = this.time - elapsed;
+    return HIT_LINE_Y - timeUntilHit * SCROLL_SPEED;
+  }
+}
+
+function getElapsed() {
+  return (performance.now() - state.startTime) / 1000;
+}
+
+function createDemoChart() {
+  const bpm = 120;
+  const beat = 60 / bpm;
+  const chart = [];
+  const patterns = [
+    ["d", "j"],
+    ["f"],
+    ["k"],
+    ["d", "f"],
+    ["j", "k"],
+    ["f"],
+    ["d"],
+    ["k"],
+  ];
+
+  for (let measure = 0; measure < 16; measure++) {
+    const baseTime = measure * 4 * beat;
+    for (let step = 0; step < 8; step++) {
+      const pattern = patterns[(measure + step) % patterns.length];
+      const time = baseTime + step * (beat / 2);
+      for (const lane of pattern) {
+        chart.push(new Note(lane, time));
+      }
+    }
+  }
+
+  chart.sort((a, b) => a.time - b.time);
+  return chart;
+}
+
+function resetGame() {
+  cancelAnimationFrame(state.animationFrame);
+  stopAudio();
+  state.pendingNotes = createDemoChart();
+  state.activeNotes = [];
+  state.startTime = 0;
+  state.running = false;
+  state.score = 0;
+  state.combo = 0;
+  state.bestCombo = 0;
+  state.totalNotes = state.pendingNotes.length;
+  state.successfulHits = 0;
+  state.lastJudgement = null;
+  state.lastJudgementTime = 0;
+  updateHud();
+  clearCanvas();
+}
+
+async function startGame() {
+  if (state.running) return;
+  if (resultDialog.open) resultDialog.close();
+  resetGame();
+  laneStates.forEach((lane) => {
+    lane.pressed = false;
+    lane.flashUntil = 0;
+  });
+  if (audioState.buffer) {
+    try {
+      await playAudio();
+      updateAudioStatus(
+        audioState.name ? `Lecture : ${audioState.name}` : "Lecture en cours"
+      );
+    } catch (error) {
+      console.error("Impossible de d√©marrer l'audio", error);
+      updateAudioStatus("Erreur lors de la lecture de l'audio");
+    }
+  }
+  state.running = true;
+  state.startTime = performance.now();
+  state.animationFrame = requestAnimationFrame(loop);
+}
+
+function loop() {
+  if (!state.running) return;
+  spawnNotes();
+  updateNotes();
+  render();
+  removeMissedNotes();
+
+  if (state.pendingNotes.length === 0 && state.activeNotes.length === 0) {
+    endGame();
+    return;
+  }
+
+  state.animationFrame = requestAnimationFrame(loop);
+}
+
+function spawnNotes() {
+  const elapsed = getElapsed();
+  while (state.pendingNotes.length && state.pendingNotes[0].time - elapsed <= LOOKAHEAD) {
+    state.activeNotes.push(state.pendingNotes.shift());
+  }
+}
+
+function updateNotes() {
+  const now = performance.now();
+  for (const laneState of laneStates.values()) {
+    if (laneState.flashUntil && laneState.flashUntil < now) {
+      laneState.flashUntil = 0;
+    }
+  }
+}
+
+function removeMissedNotes() {
+  const elapsed = getElapsed();
+  const missWindow = TIMING_WINDOWS.good / 1000 + 0.1;
+  state.activeNotes = state.activeNotes.filter((note) => {
+    if (note.hit) return false;
+    if (note.missed) return false;
+
+    const diff = elapsed - note.time;
+    if (diff > missWindow) {
+      note.missed = true;
+      state.combo = 0;
+      state.lastJudgement = "Rat√©";
+      state.lastJudgementTime = performance.now();
+      return false;
+    }
+    return true;
+  });
+}
+
+function render() {
+  clearCanvas();
+  drawLanes();
+  drawNotes();
+  drawJudgement();
+}
+
+function clearCanvas() {
+  ctx.clearRect(0, 0, canvas.width, canvas.height);
+}
+
+function drawLanes() {
+  const totalWidth = LANES.length * LANE_WIDTH + (LANES.length - 1) * LANE_GAP;
+  const startX = (canvas.width - totalWidth) / 2;
+
+  LANES.forEach((lane, index) => {
+    const x = startX + index * (LANE_WIDTH + LANE_GAP);
+    const laneState = laneStates.get(lane);
+    const flashProgress = laneState.flashUntil
+      ? Math.max(0, (laneState.flashUntil - performance.now()) / 120)
+      : 0;
+
+    const gradient = ctx.createLinearGradient(x, 0, x + LANE_WIDTH, 0);
+    gradient.addColorStop(0, laneColors[index % laneColors.length] + "33");
+    gradient.addColorStop(0.5, laneColors[index % laneColors.length] + "55");
+    gradient.addColorStop(1, laneColors[index % laneColors.length] + "33");
+
+    ctx.fillStyle = gradient;
+    ctx.fillRect(x, 0, LANE_WIDTH, canvas.height);
+
+    if (flashProgress > 0) {
+      ctx.fillStyle = `rgba(255, 255, 255, ${flashProgress.toFixed(2)})`;
+      ctx.fillRect(x, HIT_LINE_Y - 60, LANE_WIDTH, 120);
+    }
+
+    ctx.strokeStyle = "rgba(255, 255, 255, 0.15)";
+    ctx.lineWidth = 2;
+    ctx.strokeRect(x, 0, LANE_WIDTH, canvas.height);
+  });
+
+  ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
+  ctx.fillRect(
+    (canvas.width - totalWidth) / 2,
+    HIT_LINE_Y,
+    totalWidth,
+    4
+  );
+}
+
+function drawNotes() {
+  for (const note of state.activeNotes) {
+    const y = note.y;
+    if (y > canvas.height || y + NOTE_HEIGHT < 0) continue;
+    const laneIndex = LANES.indexOf(note.lane);
+    const color = laneColors[laneIndex % laneColors.length];
+    const x = note.x;
+
+    ctx.fillStyle = color;
+    ctx.shadowColor = color;
+    ctx.shadowBlur = 12;
+    ctx.fillRect(x + 12, y, LANE_WIDTH - 24, NOTE_HEIGHT);
+    ctx.shadowBlur = 0;
+  }
+}
+
+function drawJudgement() {
+  if (!state.lastJudgement) return;
+  const timeSince = performance.now() - state.lastJudgementTime;
+  if (timeSince > 700) return;
+  const opacity = 1 - timeSince / 700;
+  ctx.save();
+  ctx.globalAlpha = opacity;
+  ctx.fillStyle = "white";
+  ctx.font = "bold 36px 'Fira Sans', sans-serif";
+  ctx.textAlign = "center";
+  ctx.fillText(state.lastJudgement, canvas.width / 2, HIT_LINE_Y - 120);
+  ctx.restore();
+}
+
+function handleHit(lane) {
+  if (!state.running) return;
+  const elapsed = getElapsed();
+  const laneNotes = state.activeNotes.filter((note) => note.lane === lane && !note.hit);
+  if (laneNotes.length === 0) {
+    registerMiss();
+    return;
+  }
+
+  const note = laneNotes.reduce((closest, current) => {
+    const diffCurrent = Math.abs((current.time - elapsed) * 1000);
+    const diffClosest = Math.abs((closest.time - elapsed) * 1000);
+    return diffCurrent < diffClosest ? current : closest;
+  });
+
+  const timeDiffMs = (elapsed - note.time) * 1000;
+  const absDiff = Math.abs(timeDiffMs);
+
+  if (absDiff <= TIMING_WINDOWS.perfect) {
+    registerHit(note, "Parfait !");
+    addScore("perfect");
+  } else if (absDiff <= TIMING_WINDOWS.great) {
+    registerHit(note, "Super !");
+    addScore("great");
+  } else if (absDiff <= TIMING_WINDOWS.good) {
+    registerHit(note, "Bien");
+    addScore("good");
+  } else {
+    registerMiss();
+    return;
+  }
+
+  note.hit = true;
+  state.activeNotes = state.activeNotes.filter((n) => n !== note);
+  laneStates.get(lane).flashUntil = performance.now() + 120;
+  updateHud();
+}
+
+function registerHit(note, judgement) {
+  state.successfulHits += 1;
+  state.combo += 1;
+  state.bestCombo = Math.max(state.bestCombo, state.combo);
+  state.lastJudgement = judgement;
+  state.lastJudgementTime = performance.now();
+  note.hit = true;
+}
+
+function addScore(window) {
+  state.score += SCORE_VALUES[window];
+}
+
+function registerMiss() {
+  state.combo = 0;
+  state.lastJudgement = "Rat√©";
+  state.lastJudgementTime = performance.now();
+}
+
+function updateHud() {
+  scoreLabel.textContent = state.score.toString();
+  comboLabel.textContent = state.combo.toString();
+  const accuracy = state.totalNotes
+    ? Math.round((state.successfulHits / state.totalNotes) * 100)
+    : 100;
+  accuracyLabel.textContent = `${accuracy}%`;
+}
+
+function endGame() {
+  state.running = false;
+  cancelAnimationFrame(state.animationFrame);
+  stopAudio();
+  if (audioState.name) {
+    updateAudioStatus(`Pr√™t : ${audioState.name}`);
+  }
+  updateHud();
+  const accuracy = state.totalNotes
+    ? Math.round((state.successfulHits / state.totalNotes) * 100)
+    : 100;
+  resultScore.textContent = `Score final : ${state.score}`;
+  resultAccuracy.textContent = `Pr√©cision : ${accuracy}%`;
+  resultCombo.textContent = `Meilleur combo : ${state.bestCombo}`;
+  resultDialog.showModal();
+}
+
+function handleKeydown(event) {
+  const key = event.key.toLowerCase();
+  if (!LANES.includes(key)) return;
+  event.preventDefault();
+  handleHit(key);
+}
+
+function handleKeyup(event) {
+  const key = event.key.toLowerCase();
+  if (!LANES.includes(key)) return;
+  event.preventDefault();
+  laneStates.get(key).pressed = false;
+}
+
+startButton.addEventListener("click", startGame);
+restartButton.addEventListener("click", startGame);
+window.addEventListener("keydown", handleKeydown);
+window.addEventListener("keyup", handleKeyup);
+
+if (audioInput) {
+  audioInput.addEventListener("change", handleAudioSelection);
+}
+
+resetGame();
+
+function ensureAudioContext() {
+  if (!AudioContextClass) {
+    throw new Error("AudioContext non pris en charge par ce navigateur");
+  }
+  if (!audioState.context) {
+    audioState.context = new AudioContextClass();
+  }
+  return audioState.context;
+}
+
+function stopAudio() {
+  if (audioState.source) {
+    try {
+      audioState.source.stop();
+    } catch (error) {
+      console.warn("Erreur lors de l'arr√™t de l'audio", error);
+    }
+    audioState.source.disconnect();
+    audioState.source = null;
+  }
+}
+
+async function handleAudioSelection(event) {
+  const file = event.target.files?.[0];
+  stopAudio();
+  if (!file) {
+    audioState.buffer = null;
+    audioState.name = "";
+    updateAudioStatus("Aucun fichier charg√©");
+    return;
+  }
+
+  updateAudioStatus("Chargement...");
+
+  try {
+    const context = ensureAudioContext();
+    const arrayBuffer = await file.arrayBuffer();
+    const buffer = await decodeAudioBuffer(context, arrayBuffer);
+    audioState.buffer = buffer;
+    audioState.name = file.name;
+    updateAudioStatus(`Pr√™t : ${file.name}`);
+  } catch (error) {
+    console.error("Erreur de chargement de l'audio", error);
+    audioState.buffer = null;
+    audioState.name = "";
+    updateAudioStatus("√âchec du chargement du fichier audio");
+  }
+}
+
+async function playAudio() {
+  if (!audioState.buffer) return;
+  const context = ensureAudioContext();
+  stopAudio();
+  if (context.state === "suspended") {
+    await context.resume();
+  }
+
+  const source = context.createBufferSource();
+  source.buffer = audioState.buffer;
+  source.connect(context.destination);
+  source.start();
+  audioState.source = source;
+  audioState.startTime = context.currentTime;
+}
+
+function decodeAudioBuffer(context, arrayBuffer) {
+  if (context.decodeAudioData.length === 1) {
+    return context.decodeAudioData(arrayBuffer);
+  }
+  return new Promise((resolve, reject) => {
+    context.decodeAudioData(arrayBuffer, resolve, reject);
+  });
+}
+
+function updateAudioStatus(message) {
+  if (audioStatus) {
+    audioStatus.textContent = message;
+  }
+}
diff --git a/styles.css b/styles.css
new file mode 100644
index 0000000000000000000000000000000000000000..74b34e32365526a7a83b20c0bb4e46342f94e587
--- /dev/null
+++ b/styles.css
@@ -0,0 +1,220 @@
+:root {
+  color-scheme: dark;
+  --lane-width: 100px;
+  --lane-gap: 10px;
+  --bg-color: #0e1016;
+  --accent: #ffdb4d;
+  --lane-colors: #ff4d6d, #4d96ff, #94f6ff, #6effa3;
+  font-family: "Fira Sans", "Segoe UI", Roboto, sans-serif;
+}
+
+* {
+  box-sizing: border-box;
+}
+
+body {
+  margin: 0;
+  min-height: 100vh;
+  background: radial-gradient(circle at top, #1f2430, var(--bg-color));
+  color: #f4f6fb;
+  display: flex;
+  flex-direction: column;
+}
+
+h1,
+ h2 {
+  font-weight: 600;
+  margin: 0;
+}
+
+header.hud {
+  display: flex;
+  align-items: center;
+  justify-content: space-between;
+  padding: 1.5rem clamp(1rem, 4vw, 3rem);
+  backdrop-filter: blur(6px);
+  background: linear-gradient(135deg, rgba(255, 255, 255, 0.08), transparent);
+  box-shadow: 0 12px 24px rgba(0, 0, 0, 0.25);
+}
+
+header .stats {
+  display: flex;
+  gap: 1.5rem;
+  font-size: 1rem;
+}
+
+header button {
+  border: none;
+  padding: 0.75rem 1.5rem;
+  border-radius: 999px;
+  font-size: 1rem;
+  font-weight: 600;
+  color: #0e1016;
+  background: linear-gradient(135deg, #ffe066, #ff922b);
+  cursor: pointer;
+  transition: transform 120ms ease, box-shadow 120ms ease;
+}
+
+header button:hover {
+  transform: translateY(-1px) scale(1.02);
+  box-shadow: 0 16px 30px rgba(0, 0, 0, 0.3);
+}
+
+.audio-picker {
+  display: flex;
+  flex-direction: column;
+  gap: 0.35rem;
+  align-items: flex-start;
+  font-size: 0.9rem;
+}
+
+.audio-picker label {
+  font-weight: 600;
+}
+
+.audio-picker input[type="file"] {
+  color: #f4f6fb;
+  background: rgba(0, 0, 0, 0.25);
+  border: 1px solid rgba(255, 255, 255, 0.18);
+  border-radius: 999px;
+  padding: 0.35rem 0.75rem;
+  cursor: pointer;
+}
+
+.audio-picker p {
+  margin: 0;
+  font-size: 0.85rem;
+  color: rgba(255, 255, 255, 0.7);
+}
+
+.stage {
+  flex: 1;
+  display: grid;
+  grid-template-columns: minmax(0, 1fr) clamp(240px, 25vw, 280px);
+  gap: clamp(1rem, 4vw, 3rem);
+  padding: clamp(1rem, 3vw, 2rem);
+}
+
+.lanes {
+  position: relative;
+  display: grid;
+  place-items: center;
+  background: rgba(0, 0, 0, 0.25);
+  border-radius: 18px;
+  overflow: hidden;
+  border: 1px solid rgba(255, 255, 255, 0.08);
+}
+
+#playfield {
+  width: min(100%, 480px);
+  height: auto;
+  border-radius: 18px;
+  background: linear-gradient(180deg, rgba(255, 255, 255, 0.06), transparent);
+}
+
+.hit-line {
+  position: absolute;
+  bottom: 80px;
+  left: 50%;
+  transform: translateX(-50%);
+  width: calc(4 * var(--lane-width) + 3 * var(--lane-gap));
+  height: 4px;
+  background: rgba(255, 255, 255, 0.7);
+  box-shadow: 0 0 12px rgba(255, 255, 255, 0.6);
+}
+
+.lane-labels {
+  position: absolute;
+  bottom: 32px;
+  display: flex;
+  gap: var(--lane-gap);
+  font-weight: 700;
+  letter-spacing: 0.08em;
+}
+
+.lane-labels span {
+  width: var(--lane-width);
+  text-align: center;
+  padding: 0.4rem 0;
+  border-radius: 10px;
+  background: rgba(0, 0, 0, 0.45);
+  box-shadow: inset 0 0 8px rgba(0, 0, 0, 0.6);
+}
+
+.panels {
+  display: grid;
+  gap: 1.5rem;
+  align-content: start;
+}
+
+.panel {
+  padding: 1.5rem;
+  background: rgba(255, 255, 255, 0.05);
+  border-radius: 16px;
+  box-shadow: 0 12px 30px rgba(0, 0, 0, 0.2);
+}
+
+.panel ul {
+  list-style: none;
+  padding: 0;
+  margin: 1rem 0 0;
+  display: grid;
+  gap: 0.4rem;
+}
+
+footer {
+  text-align: center;
+  padding: 1rem;
+  font-size: 0.85rem;
+  color: rgba(255, 255, 255, 0.6);
+}
+
+kbd {
+  display: inline-block;
+  padding: 0.2rem 0.4rem;
+  border-radius: 6px;
+  background: rgba(0, 0, 0, 0.6);
+  border: 1px solid rgba(255, 255, 255, 0.2);
+}
+
+#result-dialog::backdrop {
+  background: rgba(0, 0, 0, 0.6);
+}
+
+#result-dialog {
+  border: none;
+  border-radius: 18px;
+  padding: 2rem 2.5rem;
+  background: rgba(15, 17, 25, 0.9);
+  color: #f4f6fb;
+  box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4);
+}
+
+#result-dialog button {
+  margin-top: 1rem;
+  padding: 0.75rem 1.5rem;
+  border: none;
+  border-radius: 999px;
+  font-size: 1rem;
+  font-weight: 600;
+  color: #0e1016;
+  background: linear-gradient(135deg, #94f6ff, #4d96ff);
+  cursor: pointer;
+}
+
+@media (max-width: 900px) {
+  header.hud {
+    flex-wrap: wrap;
+    gap: 1rem;
+    justify-content: center;
+    text-align: center;
+  }
+
+  .stage {
+    grid-template-columns: 1fr;
+  }
+
+  .panels {
+    grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
+  }
+}
 
EOF
)
