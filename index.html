<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Drum Hero</title>
    <style>
:root {
  color-scheme: dark;
  --lane-width: 100px;
  --lane-gap: 10px;
  --bg-color: #0e1016;
  --accent: #ffdb4d;
  --lane-colors: #ff4d6d, #4d96ff, #94f6ff, #6effa3;
  font-family: "Fira Sans", "Segoe UI", Roboto, sans-serif;
}

* {
  box-sizing: border-box;
}

body {
  margin: 0;
  min-height: 100vh;
  background: radial-gradient(circle at top, #1f2430, var(--bg-color));
  color: #f4f6fb;
  display: flex;
  flex-direction: column;
}

h1,
 h2 {
  font-weight: 600;
  margin: 0;
}

header.hud {
  display: flex;
  align-items: center;
  justify-content: space-between;
  flex-wrap: wrap;
  gap: clamp(1rem, 3vw, 2.5rem);
  padding: 1.5rem clamp(1rem, 4vw, 3rem);
  backdrop-filter: blur(6px);
  background: linear-gradient(135deg, rgba(255, 255, 255, 0.08), transparent);
  box-shadow: 0 12px 24px rgba(0, 0, 0, 0.25);
}

header .stats {
  display: flex;
  gap: 1.5rem;
  font-size: 1rem;
  flex-wrap: wrap;
}

header .stats p {
  margin: 0;
}

header button {
  border: none;
  padding: 0.75rem 1.5rem;
  border-radius: 999px;
  font-size: 1rem;
  font-weight: 600;
  color: #0e1016;
  background: linear-gradient(135deg, #ffe066, #ff922b);
  cursor: pointer;
  transition: transform 120ms ease, box-shadow 120ms ease;
}

header button:hover {
  transform: translateY(-1px) scale(1.02);
  box-shadow: 0 16px 30px rgba(0, 0, 0, 0.3);
}

.audio-picker {
  display: flex;
  flex-direction: column;
  gap: 0.35rem;
  align-items: flex-start;
  font-size: 0.9rem;
}

.audio-picker label {
  font-weight: 600;
}

.audio-picker input[type="file"] {
  color: #f4f6fb;
  background: rgba(0, 0, 0, 0.25);
  border: 1px solid rgba(255, 255, 255, 0.18);
  border-radius: 999px;
  padding: 0.35rem 0.75rem;
  cursor: pointer;
}

.audio-picker p {
  margin: 0;
  font-size: 0.85rem;
  color: rgba(255, 255, 255, 0.7);
}

.control-group {
  display: flex;
  flex-direction: column;
  gap: 0.65rem;
  align-items: flex-start;
}

.difficulty-picker {
  display: flex;
  flex-direction: column;
  gap: 0.3rem;
  font-size: 0.9rem;
}

.difficulty-picker label {
  font-weight: 600;
}

.difficulty-picker select {
  background: rgba(0, 0, 0, 0.25);
  border: 1px solid rgba(255, 255, 255, 0.18);
  border-radius: 999px;
  padding: 0.45rem 1.15rem;
  color: #f4f6fb;
  font-weight: 500;
  cursor: pointer;
}

.difficulty-picker select:focus-visible {
  outline: 2px solid var(--accent);
  outline-offset: 2px;
}

.stage {
  flex: 1;
  display: grid;
  grid-template-columns: minmax(0, 1fr) clamp(240px, 25vw, 280px);
  gap: clamp(1rem, 4vw, 3rem);
  padding: clamp(1rem, 3vw, 2rem);
}

.lanes {
  position: relative;
  display: grid;
  place-items: center;
  background: rgba(0, 0, 0, 0.25);
  border-radius: 18px;
  overflow: hidden;
  border: 1px solid rgba(255, 255, 255, 0.08);
}

#playfield {
  width: min(100%, 480px);
  height: auto;
  border-radius: 18px;
  background: linear-gradient(180deg, rgba(255, 255, 255, 0.06), transparent);
}

.hit-line {
  position: absolute;
  bottom: 80px;
  left: 50%;
  transform: translateX(-50%);
  width: calc(4 * var(--lane-width) + 3 * var(--lane-gap));
  height: 4px;
  background: rgba(255, 255, 255, 0.7);
  box-shadow: 0 0 12px rgba(255, 255, 255, 0.6);
}

.lane-labels {
  position: absolute;
  bottom: 32px;
  display: flex;
  gap: var(--lane-gap);
  font-weight: 700;
  letter-spacing: 0.08em;
}

.lane-labels span {
  width: var(--lane-width);
  text-align: center;
  padding: 0.4rem 0;
  border-radius: 10px;
  background: rgba(0, 0, 0, 0.45);
  box-shadow: inset 0 0 8px rgba(0, 0, 0, 0.6);
}

.panels {
  display: grid;
  gap: 1.5rem;
  align-content: start;
}

.panel {
  padding: 1.5rem;
  background: rgba(255, 255, 255, 0.05);
  border-radius: 16px;
  box-shadow: 0 12px 30px rgba(0, 0, 0, 0.2);
}

.panel ul {
  list-style: none;
  padding: 0;
  margin: 1rem 0 0;
  display: grid;
  gap: 0.4rem;
}

footer {
  text-align: center;
  padding: 1rem;
  font-size: 0.85rem;
  color: rgba(255, 255, 255, 0.6);
}

kbd {
  display: inline-block;
  padding: 0.2rem 0.4rem;
  border-radius: 6px;
  background: rgba(0, 0, 0, 0.6);
  border: 1px solid rgba(255, 255, 255, 0.2);
}

#result-dialog::backdrop {
  background: rgba(0, 0, 0, 0.6);
}

#result-dialog {
  border: none;
  border-radius: 18px;
  padding: 2rem 2.5rem;
  background: rgba(15, 17, 25, 0.9);
  color: #f4f6fb;
  box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4);
}

#result-dialog button {
  margin-top: 1rem;
  padding: 0.75rem 1.5rem;
  border: none;
  border-radius: 999px;
  font-size: 1rem;
  font-weight: 600;
  color: #0e1016;
  background: linear-gradient(135deg, #94f6ff, #4d96ff);
  cursor: pointer;
}

@media (max-width: 900px) {
  header.hud {
    flex-wrap: wrap;
    gap: 1rem;
    justify-content: center;
    text-align: center;
  }

  .stage {
    grid-template-columns: 1fr;
  }

  .panels {
    grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
  }
}
    </style>
  </head>
  <body>
    <header class="hud">
      <h1>Drum Hero</h1>
      <section class="stats">
        <p><strong>Score :</strong> <span id="score">0</span></p>
        <p><strong>Combo :</strong> <span id="combo">0</span></p>
        <p><strong>Pr√©cision :</strong> <span id="accuracy">100%</span></p>
        <p><strong>Mode :</strong> <span id="difficulty-label">Normale</span></p>
      </section>
      <div class="control-group">
        <button id="start-button" type="button">‚ñ∂Ô∏è D√©marrer</button>
        <div class="difficulty-picker">
          <label for="difficulty">Difficult√© :</label>
          <select id="difficulty" name="difficulty">
            <option value="easy">Facile</option>
            <option value="normal" selected>Normale</option>
            <option value="hard">Difficile</option>
          </select>
        </div>
      </div>
      <div class="audio-picker">
        <label for="audio-file">üéµ Charger un MP3 :</label>
        <input
          id="audio-file"
          type="file"
          accept="audio/mpeg,audio/mp3,audio/*"
        />
        <p id="audio-status">Aucun fichier charg√©</p>
      </div>
    </header>

    <main class="stage">
      <div class="lanes" role="presentation">
        <canvas id="playfield" width="480" height="640" aria-label="Piste de jeu"></canvas>
        <div class="hit-line" aria-hidden="true"></div>
        <div class="lane-labels" aria-hidden="true">
          <span>D</span>
          <span>F</span>
          <span>J</span>
          <span>K</span>
        </div>
      </div>
      <aside class="panels">
        <section class="panel">
          <h2>Contr√¥les</h2>
          <ul>
            <li>Touche <kbd>D</kbd></li>
            <li>Touche <kbd>F</kbd></li>
            <li>Touche <kbd>J</kbd></li>
            <li>Touche <kbd>K</kbd></li>
          </ul>
        </section>
        <section class="panel">
          <h2>Astuce</h2>
          <p>
            Appuie sur la touche correspondant √† la colonne lorsque la note
            arrive sur la ligne blanche. Le timing compte !
          </p>
        </section>
      </aside>
    </main>

    <footer>
      <p>Jeu inspir√© par Guitar Hero. Code modernis√© pour de meilleures performances.</p>
    </footer>

    <dialog id="result-dialog">
      <article>
        <h2>Fin de partie</h2>
        <p id="result-score"></p>
        <p id="result-accuracy"></p>
        <p id="result-combo"></p>
        <p id="result-difficulty"></p>
        <button id="restart-button" type="button">Rejouer</button>
      </article>
    </dialog>

    <script type="module">
const canvas = document.getElementById("playfield");
const ctx = canvas.getContext("2d");

const scoreLabel = document.getElementById("score");
const comboLabel = document.getElementById("combo");
const accuracyLabel = document.getElementById("accuracy");
const startButton = document.getElementById("start-button");
const resultDialog = document.getElementById("result-dialog");
const restartButton = document.getElementById("restart-button");
const resultScore = document.getElementById("result-score");
const resultAccuracy = document.getElementById("result-accuracy");
const resultCombo = document.getElementById("result-combo");
const resultDifficulty = document.getElementById("result-difficulty");
const audioInput = document.getElementById("audio-file");
const audioStatus = document.getElementById("audio-status");
const difficultySelect = document.getElementById("difficulty");
const difficultyLabel = document.getElementById("difficulty-label");

const AudioContextClass = window.AudioContext || window.webkitAudioContext;

const LANES = ["d", "f", "j", "k"];
const LANE_WIDTH = 100;
const LANE_GAP = 10;
const NOTE_HEIGHT = 28;
const HIT_LINE_Y = canvas.height - 100;
const LOOKAHEAD = 2.5; // secondes

const DIFFICULTIES = {
  easy: {
    label: "Facile",
    scrollSpeed: 260,
    bpm: 90,
    measures: 12,
    stepsPerBeat: 2,
    patterns: [
      ["d"],
      [],
      ["f"],
      [],
      ["j"],
      [],
      ["k"],
      [],
    ],
    timingWindows: {
      perfect: 85,
      great: 130,
      good: 190,
    },
  },
  normal: {
    label: "Normale",
    scrollSpeed: 320,
    bpm: 110,
    measures: 16,
    stepsPerBeat: 2,
    patterns: [
      ["d"],
      ["f"],
      ["j"],
      ["k"],
      ["d"],
      ["f", "j"],
      ["k"],
      ["f"],
    ],
    timingWindows: {
      perfect: 65,
      great: 105,
      good: 160,
    },
  },
  hard: {
    label: "Difficile",
    scrollSpeed: 360,
    bpm: 120,
    measures: 16,
    stepsPerBeat: 2,
    patterns: [
      ["d", "j"],
      ["f"],
      ["k"],
      ["d", "f"],
      ["j", "k"],
      ["f"],
      ["d"],
      ["k"],
    ],
    timingWindows: {
      perfect: 55,
      great: 95,
      good: 140,
    },
  },
};

const defaultDifficulty =
  difficultySelect && DIFFICULTIES[difficultySelect.value]
    ? difficultySelect.value
    : "hard";

let currentScrollSpeed = DIFFICULTIES[defaultDifficulty].scrollSpeed;
let timingWindows = { ...DIFFICULTIES[defaultDifficulty].timingWindows };
const SCORE_VALUES = { perfect: 300, great: 150, good: 60 };

const laneColors = getComputedStyle(document.documentElement)
  .getPropertyValue("--lane-colors")
  .split(",")
  .map((color) => color.trim());

const laneStates = new Map(LANES.map((key) => [key, { pressed: false, flashUntil: 0 }]));

const state = {
  difficulty: defaultDifficulty,
  lastRunDifficulty: defaultDifficulty,
  startTime: 0,
  activeNotes: [],
  pendingNotes: [],
  animationFrame: 0,
  running: false,
  score: 0,
  combo: 0,
  bestCombo: 0,
  totalNotes: 0,
  successfulHits: 0,
  lastJudgement: null,
  lastJudgementTime: 0,
};

const audioState = {
  context: null,
  buffer: null,
  source: null,
  startTime: 0,
  name: "",
};

class Note {
  constructor(lane, time) {
    this.lane = lane;
    this.time = time;
    this.hit = false;
    this.missed = false;
  }

  get x() {
    const laneIndex = LANES.indexOf(this.lane);
    const totalWidth = LANES.length * LANE_WIDTH + (LANES.length - 1) * LANE_GAP;
    const startX = (canvas.width - totalWidth) / 2;
    return startX + laneIndex * (LANE_WIDTH + LANE_GAP);
  }

  get y() {
    const elapsed = getElapsed();
    const timeUntilHit = this.time - elapsed;
    return HIT_LINE_Y - timeUntilHit * currentScrollSpeed;
  }
}

function getElapsed() {
  return (performance.now() - state.startTime) / 1000;
}

function getDifficultySettings(difficultyKey) {
  return DIFFICULTIES[difficultyKey] ?? DIFFICULTIES.hard;
}

function createChart(difficultyKey) {
  const settings = getDifficultySettings(difficultyKey);
  const beat = 60 / settings.bpm;
  const chart = [];
  const stepsPerMeasure = settings.stepsPerBeat * 4;

  for (let measure = 0; measure < settings.measures; measure++) {
    const baseTime = measure * 4 * beat;
    for (let step = 0; step < stepsPerMeasure; step++) {
      const pattern = settings.patterns[(measure + step) % settings.patterns.length];
      if (!pattern.length) continue;
      const time = baseTime + (step / settings.stepsPerBeat) * beat;
      for (const lane of pattern) {
        chart.push(new Note(lane, time));
      }
    }
  }

  chart.sort((a, b) => a.time - b.time);
  return chart;
}

function applyDifficultySettings(difficultyKey) {
  const settings = getDifficultySettings(difficultyKey);
  currentScrollSpeed = settings.scrollSpeed;
  timingWindows = { ...settings.timingWindows };
}

function resetGame() {
  cancelAnimationFrame(state.animationFrame);
  stopAudio();
  if (resultDialog.open) {
    resultDialog.close();
  }
  applyDifficultySettings(state.difficulty);
  state.pendingNotes = createChart(state.difficulty);
  state.activeNotes = [];
  state.startTime = 0;
  state.running = false;
  state.score = 0;
  state.combo = 0;
  state.bestCombo = 0;
  state.totalNotes = state.pendingNotes.length;
  state.successfulHits = 0;
  state.lastJudgement = null;
  state.lastJudgementTime = 0;
  if (resultDifficulty) {
    resultDifficulty.textContent = "";
  }
  laneStates.forEach((laneState) => {
    laneState.pressed = false;
    laneState.flashUntil = 0;
  });
  updateHud();
  clearCanvas();
}

async function startGame() {
  if (state.running) return;
  if (resultDialog.open) resultDialog.close();
  state.lastRunDifficulty = state.difficulty;
  resetGame();
  laneStates.forEach((lane) => {
    lane.pressed = false;
    lane.flashUntil = 0;
  });
  if (audioState.buffer) {
    try {
      await playAudio();
      updateAudioStatus(
        audioState.name ? `Lecture : ${audioState.name}` : "Lecture en cours"
      );
    } catch (error) {
      console.error("Impossible de d√©marrer l'audio", error);
      updateAudioStatus("Erreur lors de la lecture de l'audio");
    }
  }
  state.running = true;
  state.startTime = performance.now();
  state.animationFrame = requestAnimationFrame(loop);
}

function loop() {
  if (!state.running) return;
  spawnNotes();
  updateNotes();
  render();
  removeMissedNotes();

  if (state.pendingNotes.length === 0 && state.activeNotes.length === 0) {
    endGame();
    return;
  }

  state.animationFrame = requestAnimationFrame(loop);
}

function spawnNotes() {
  const elapsed = getElapsed();
  while (state.pendingNotes.length && state.pendingNotes[0].time - elapsed <= LOOKAHEAD) {
    state.activeNotes.push(state.pendingNotes.shift());
  }
}

function updateNotes() {
  const now = performance.now();
  for (const laneState of laneStates.values()) {
    if (laneState.flashUntil && laneState.flashUntil < now) {
      laneState.flashUntil = 0;
    }
  }
}

function removeMissedNotes() {
  const elapsed = getElapsed();
  const missWindow = timingWindows.good / 1000 + 0.1;
  state.activeNotes = state.activeNotes.filter((note) => {
    if (note.hit) return false;
    if (note.missed) return false;

    const diff = elapsed - note.time;
    if (diff > missWindow) {
      note.missed = true;
      state.combo = 0;
      state.lastJudgement = "Rat√©";
      state.lastJudgementTime = performance.now();
      return false;
    }
    return true;
  });
}

function render() {
  clearCanvas();
  drawLanes();
  drawNotes();
  drawJudgement();
}

function clearCanvas() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
}

function drawLanes() {
  const totalWidth = LANES.length * LANE_WIDTH + (LANES.length - 1) * LANE_GAP;
  const startX = (canvas.width - totalWidth) / 2;

  LANES.forEach((lane, index) => {
    const x = startX + index * (LANE_WIDTH + LANE_GAP);
    const laneState = laneStates.get(lane);
    const flashProgress = laneState.flashUntil
      ? Math.max(0, (laneState.flashUntil - performance.now()) / 120)
      : 0;

    const gradient = ctx.createLinearGradient(x, 0, x + LANE_WIDTH, 0);
    gradient.addColorStop(0, laneColors[index % laneColors.length] + "33");
    gradient.addColorStop(0.5, laneColors[index % laneColors.length] + "55");
    gradient.addColorStop(1, laneColors[index % laneColors.length] + "33");

    ctx.fillStyle = gradient;
    ctx.fillRect(x, 0, LANE_WIDTH, canvas.height);

    if (flashProgress > 0) {
      ctx.fillStyle = `rgba(255, 255, 255, ${flashProgress.toFixed(2)})`;
      ctx.fillRect(x, HIT_LINE_Y - 60, LANE_WIDTH, 120);
    }

    ctx.strokeStyle = "rgba(255, 255, 255, 0.15)";
    ctx.lineWidth = 2;
    ctx.strokeRect(x, 0, LANE_WIDTH, canvas.height);
  });

  ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
  ctx.fillRect(
    (canvas.width - totalWidth) / 2,
    HIT_LINE_Y,
    totalWidth,
    4
  );
}

function drawNotes() {
  for (const note of state.activeNotes) {
    const y = note.y;
    if (y > canvas.height || y + NOTE_HEIGHT < 0) continue;
    const laneIndex = LANES.indexOf(note.lane);
    const color = laneColors[laneIndex % laneColors.length];
    const x = note.x;

    ctx.fillStyle = color;
    ctx.shadowColor = color;
    ctx.shadowBlur = 12;
    ctx.fillRect(x + 12, y, LANE_WIDTH - 24, NOTE_HEIGHT);
    ctx.shadowBlur = 0;
  }
}

function drawJudgement() {
  if (!state.lastJudgement) return;
  const timeSince = performance.now() - state.lastJudgementTime;
  if (timeSince > 700) return;
  const opacity = 1 - timeSince / 700;
  ctx.save();
  ctx.globalAlpha = opacity;
  ctx.fillStyle = "white";
  ctx.font = "bold 36px 'Fira Sans', sans-serif";
  ctx.textAlign = "center";
  ctx.fillText(state.lastJudgement, canvas.width / 2, HIT_LINE_Y - 120);
  ctx.restore();
}

function handleHit(lane) {
  if (!state.running) return;
  const elapsed = getElapsed();
  const laneNotes = state.activeNotes.filter((note) => note.lane === lane && !note.hit);
  if (laneNotes.length === 0) {
    registerMiss();
    return;
  }

  const note = laneNotes.reduce((closest, current) => {
    const diffCurrent = Math.abs((current.time - elapsed) * 1000);
    const diffClosest = Math.abs((closest.time - elapsed) * 1000);
    return diffCurrent < diffClosest ? current : closest;
  });

  const timeDiffMs = (elapsed - note.time) * 1000;
  const absDiff = Math.abs(timeDiffMs);

  if (absDiff <= timingWindows.perfect) {
    registerHit(note, "Parfait !");
    addScore("perfect");
  } else if (absDiff <= timingWindows.great) {
    registerHit(note, "Super !");
    addScore("great");
  } else if (absDiff <= timingWindows.good) {
    registerHit(note, "Bien");
    addScore("good");
  } else {
    registerMiss();
    return;
  }

  note.hit = true;
  state.activeNotes = state.activeNotes.filter((n) => n !== note);
  laneStates.get(lane).flashUntil = performance.now() + 120;
  updateHud();
}

function registerHit(note, judgement) {
  state.successfulHits += 1;
  state.combo += 1;
  state.bestCombo = Math.max(state.bestCombo, state.combo);
  state.lastJudgement = judgement;
  state.lastJudgementTime = performance.now();
  note.hit = true;
}

function addScore(window) {
  state.score += SCORE_VALUES[window];
}

function registerMiss() {
  state.combo = 0;
  state.lastJudgement = "Rat√©";
  state.lastJudgementTime = performance.now();
}

function updateHud() {
  scoreLabel.textContent = state.score.toString();
  comboLabel.textContent = state.combo.toString();
  const accuracy = state.totalNotes
    ? Math.round((state.successfulHits / state.totalNotes) * 100)
    : 100;
  accuracyLabel.textContent = `${accuracy}%`;
  if (difficultyLabel) {
    difficultyLabel.textContent = getDifficultySettings(state.difficulty).label;
  }
  if (difficultySelect && difficultySelect.value !== state.difficulty) {
    difficultySelect.value = state.difficulty;
  }
}

function handleDifficultyChange(event) {
  const selected = event.target.value;
  if (!DIFFICULTIES[selected]) {
    return;
  }
  if (state.running) {
    event.target.value = state.difficulty;
    return;
  }
  state.difficulty = selected;
  resetGame();
}

function endGame() {
  state.running = false;
  cancelAnimationFrame(state.animationFrame);
  stopAudio();
  if (audioState.name) {
    updateAudioStatus(`Pr√™t : ${audioState.name}`);
  }
  updateHud();
  const accuracy = state.totalNotes
    ? Math.round((state.successfulHits / state.totalNotes) * 100)
    : 100;
  resultScore.textContent = `Score final : ${state.score}`;
  resultAccuracy.textContent = `Pr√©cision : ${accuracy}%`;
  resultCombo.textContent = `Meilleur combo : ${state.bestCombo}`;
  if (resultDifficulty) {
    const settings = getDifficultySettings(state.lastRunDifficulty);
    resultDifficulty.textContent = `Difficult√© : ${settings.label}`;
  }
  resultDialog.showModal();
}

function handleKeydown(event) {
  const key = event.key.toLowerCase();
  if (!LANES.includes(key)) return;
  event.preventDefault();
  handleHit(key);
}

function handleKeyup(event) {
  const key = event.key.toLowerCase();
  if (!LANES.includes(key)) return;
  event.preventDefault();
  laneStates.get(key).pressed = false;
}

startButton.addEventListener("click", startGame);
restartButton.addEventListener("click", startGame);
window.addEventListener("keydown", handleKeydown);
window.addEventListener("keyup", handleKeyup);

if (audioInput) {
  audioInput.addEventListener("change", handleAudioSelection);
}

if (difficultySelect) {
  difficultySelect.addEventListener("change", handleDifficultyChange);
}

resetGame();

function ensureAudioContext() {
  if (!AudioContextClass) {
    throw new Error("AudioContext non pris en charge par ce navigateur");
  }
  if (!audioState.context) {
    audioState.context = new AudioContextClass();
  }
  return audioState.context;
}

function stopAudio() {
  if (audioState.source) {
    try {
      audioState.source.stop();
    } catch (error) {
      console.warn("Erreur lors de l'arr√™t de l'audio", error);
    }
    audioState.source.disconnect();
    audioState.source = null;
  }
}

async function handleAudioSelection(event) {
  const file = event.target.files?.[0];
  stopAudio();
  if (!file) {
    audioState.buffer = null;
    audioState.name = "";
    updateAudioStatus("Aucun fichier charg√©");
    return;
  }

  updateAudioStatus("Chargement...");

  try {
    const context = ensureAudioContext();
    const arrayBuffer = await file.arrayBuffer();
    const buffer = await decodeAudioBuffer(context, arrayBuffer);
    audioState.buffer = buffer;
    audioState.name = file.name;
    updateAudioStatus(`Pr√™t : ${file.name}`);
  } catch (error) {
    console.error("Erreur de chargement de l'audio", error);
    audioState.buffer = null;
    audioState.name = "";
    updateAudioStatus("√âchec du chargement du fichier audio");
  }
}

async function playAudio() {
  if (!audioState.buffer) return;
  const context = ensureAudioContext();
  stopAudio();
  if (context.state === "suspended") {
    await context.resume();
  }

  const source = context.createBufferSource();
  source.buffer = audioState.buffer;
  source.connect(context.destination);
  source.start();
  audioState.source = source;
  audioState.startTime = context.currentTime;
}

function decodeAudioBuffer(context, arrayBuffer) {
  if (context.decodeAudioData.length === 1) {
    return context.decodeAudioData(arrayBuffer);
  }
  return new Promise((resolve, reject) => {
    context.decodeAudioData(arrayBuffer, resolve, reject);
  });
}

function updateAudioStatus(message) {
  if (audioStatus) {
    audioStatus.textContent = message;
  }
}
    </script>
  </body>
</html>
